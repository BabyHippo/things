/*
 * Module dependencies.
 */
var utils=require("./utils");
/*
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */
var StateMachine=module.exports=exports=function StateMachine(){this.paths={};this.states={}}
/*
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */
;StateMachine.ctor=function(){var b=utils.args(arguments);var a=function(){StateMachine.apply(this,arguments);this.stateNames=b;var c=b.length,d;while(c--){d=b[c];this.states[d]={}}};a.prototype.__proto__=StateMachine.prototype;b.forEach(function(c){a.prototype[c]=function(d){this._changeState(d,c)}});return a};
/*
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */
StateMachine.prototype._changeState=function _changeState(b,a){var c=this.states[this.paths[b]];if(c){delete c[b]}this.paths[b]=a;this.states[a][b]=true}
/*
 * ignore
 */
;StateMachine.prototype.clear=function clear(d){var b=Object.keys(this.states[d]),a=b.length,c;while(a--){c=b[a];delete this.states[d][c];delete this.paths[c]}}
/*
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */
;StateMachine.prototype.some=function some(){var a=this;var b=arguments.length?arguments:this.stateNames;return Array.prototype.some.call(b,function(c){return Object.keys(a.states[c]).length})}
/*
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */
;StateMachine.prototype._iter=function _iter(a){return function(){var c=arguments.length,f=utils.args(arguments,0,c-1),b=arguments[c-1];if(!f.length){f=this.stateNames}var e=this;var d=f.reduce(function(g,h){return g.concat(Object.keys(e.states[h]))},[]);return d[a](function(h,g,j){return b(h,g,j)})}}
/*
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */
;StateMachine.prototype.forEach=function forEach(){this.forEach=this._iter("forEach");return this.forEach.apply(this,arguments)}
/*
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */
;StateMachine.prototype.map=function map(){this.map=this._iter("map");return this.map.apply(this,arguments)};