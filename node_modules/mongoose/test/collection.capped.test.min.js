var start=require("./common"),mongoose=start.mongoose,assert=require("assert"),Schema=mongoose.Schema,random=require("../lib/utils").random;var capped=new Schema({key:"string",val:"number"});capped.set("capped",{size:1000});var coll="capped_"+random();describe("collections: capped:",function(){it("schemas should have option size",function(){assert.ok(capped.options.capped);assert.equal(1000,capped.options.capped.size)});it("creation",function(c){var b=start();var a=b.model("Capped",capped,coll);a.collection.isCapped(function(e,f){assert.ifError(e);assert.ok(f,"should create a capped collection");var d=b.model("Capped2",capped,coll);d.collection.isCapped(function(g,h){b.close();assert.ifError(g);assert.ok(h,"should reuse the capped collection in the db");assert.equal(a.collection.name,d.collection.name);c()})})});it("creation using a number",function(c){var b=start();var d=new Schema({key:"string"},{capped:100});var a=b.model("Capped3",d);a.collection.options(function(e,g){assert.ifError(e);assert.ok(g.capped,"should create a capped collection");assert.equal(100,g.size);var h="";for(var f=0;f<3800;++f){h+="A"}a.create({key:h},function(j,i){assert.ifError(j);var k=i.id;a.count(function(n,m){assert.ifError(n);assert.equal(1,m);var l=new a({key:h});l.save(function(p,o,q){assert.ifError(p);assert.equal(1,q);a.find(function(s,r){assert.ifError(s);assert.equal(1,r.length);l=r[0];assert.notEqual(k,l.id);l.key=l.key+h;l.save(function(t){assert.ok(t);l.remove(function(u){b.close();assert.ok(u);assert.equal(10101,u.code);c()})})})})})})})});it("attempting to use existing non-capped collection as capped emits error",function(c){var b=start();var d={safe:true};var a="capped_existing_"+random();b.on("open",function(){b.db.createCollection(a,d,function(f){if(f){b.close()}assert.ifError(f);var g;b.on("error",function(h){clearTimeout(g);b.close();assert.ok(/non-capped collection exists/.test(h));c()});var e=b.model("CappedExisting",capped,a);g=setTimeout(function(){b.close();throw new Error("capped test timeout")},900)})})})});