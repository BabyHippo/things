var start=require("./common"),mongoose=start.mongoose,Schema=mongoose.Schema,utils=require("../lib/utils"),StateMachine=require("../lib/statemachine"),ObjectId=require("../lib/types/objectid"),MongooseBuffer=require("../lib/types/buffer"),assert=require("assert");var ActiveRoster=StateMachine.ctor("require","init","modify");describe("utils",function(){it("should detect a path as required if it has been required",function(){var a=new ActiveRoster();a.require("hello");assert.equal(a.paths.hello,"require")});it("should detect a path as inited if it has been inited",function(){var a=new ActiveRoster();a.init("hello");assert.equal(a.paths.hello,"init")});it("should detect a path as modified",function(){var a=new ActiveRoster();a.modify("hello");assert.equal(a.paths.hello,"modify")});it("should remove a path from an old state upon a state change",function(){var a=new ActiveRoster();a.init("hello");a.modify("hello");assert.ok(!a.states.init.hasOwnProperty("hello"));assert.ok(a.states.modify.hasOwnProperty("hello"))});it("forEach should be able to iterate through the paths belonging to one state",function(){var a=new ActiveRoster();a.init("hello");a.init("goodbye");a.modify("world");a.require("foo");a.forEach("init",function(b){assert.ok(~["hello","goodbye"].indexOf(b))})});it("forEach should be able to iterate through the paths in the union of two or more states",function(){var a=new ActiveRoster();a.init("hello");a.init("goodbye");a.modify("world");a.require("foo");a.forEach("modify","require",function(b){assert.ok(~["world","foo"].indexOf(b))})});it("forEach should iterate through all paths that have any state if given no state arguments",function(){var a=new ActiveRoster();a.init("hello");a.init("goodbye");a.modify("world");a.require("foo");a.forEach(function(b){assert.ok(~["hello","goodbye","world","foo"].indexOf(b))})});it("should be able to detect if at least one path exists in a set of states",function(){var a=new ActiveRoster();a.init("hello");a.modify("world");assert.ok(a.some("init"));assert.ok(a.some("modify"));assert.ok(!a.some("require"));assert.ok(a.some("init","modify"));assert.ok(a.some("init","require"));assert.ok(a.some("modify","require"))});it("should be able to `map` over the set of paths in a given state",function(){var a=new ActiveRoster();a.init("hello");a.modify("world");a.require("iAmTheWalrus");var b=a.map("init","modify",function(c){return c+"-suffix"});assert.deepEqual(b,["hello-suffix","world-suffix"])});it("should `map` over all states' paths if no states are specified in a `map` invocation",function(){var a=new ActiveRoster();a.init("hello");a.modify("world");a.require("iAmTheWalrus");var b=a.map(function(c){return c+"-suffix"});assert.deepEqual(b,["iAmTheWalrus-suffix","hello-suffix","world-suffix"])});it("test utils.options",function(){var b={a:1,b:2,c:3,0:"zero1"};var a={b:10,d:20,0:"zero2"};var c=utils.options(a,b);assert.equal(1,c.a);assert.equal(c.b,2);assert.equal(c.c,3);assert.equal(c.d,20);assert.deepEqual(b.d,c.d);assert.equal(c["0"],"zero1");var d=utils.options(a);assert.equal(d.b,10);assert.equal(d.d,20);assert.equal(d["0"],"zero2");assert.deepEqual(a,d);assert.notEqual(a,d)});it("test deepEquals on ObjectIds",function(){var e=(new ObjectId).toString();var c=new ObjectId(e),d=new ObjectId(e);assert.ok(utils.deepEqual(c,d));assert.ok(utils.deepEqual(c,c));assert.ok(!utils.deepEqual(c,new ObjectId))});it("deepEquals on MongooseDocumentArray works",function(){var b=start(),a=new Schema({a:String}),c=b.model("deepEqualsOnMongooseDocArray",new Schema({a1:[a],a2:[a]}));b.close();var d=new c({a1:[{a:"Hi"},{a:"Bye"}]});d.a2=d.a1;assert.ok(utils.deepEqual(d.a1,d.a2));var e=new c;e.init(d.toObject());assert.ok(utils.deepEqual(d.a1,e.a1));e.set(d.toObject());assert.ok(utils.deepEqual(d.a1,e.a1))});it("deepEquals with MongooseBuffer",function(){var k="this is the day";var f=new MongooseBuffer(k);var g=new MongooseBuffer(k);var h=new Buffer(k);var i=new Buffer("this is the way");var j=new Buffer("other length");assert.ok(utils.deepEqual(f,g));assert.ok(utils.deepEqual(f,h));assert.ok(!utils.deepEqual(f,i));assert.ok(!utils.deepEqual(f,j));assert.ok(!utils.deepEqual(f,[]));assert.ok(!utils.deepEqual([],f))})});